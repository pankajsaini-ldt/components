{"componentChunkName":"component---src-layout-documentation-tsx","path":"/components/forms/radio/","result":{"data":{"site":{"siteMetadata":{"title":"Looker UI Components"}},"mdx":{"id":"fef86f05-dd9e-5a70-bc3b-40d458a36000","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Radio\",\n  \"propsOf\": \"Radio\",\n  \"figma\": \"file/2MG6DoSjk4IaLnjjFCnKFf/Forms\",\n  \"github\": \"Form/Inputs/Radio/Radio.tsx\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<Radio />\"), \" component renders a single radio button on the page, with no accompanying label. It is generally used to construct higher-order components like the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<FieldRadio />\"), \". If you are building a form, you probably want to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<FieldRadio />\"), \" instead as it provides label support.\"), mdx(\"h2\", null, \"Checked Property\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<Radio />\"), \" component accepts the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"checked\"), \" property, which either sets the radio button as selected or not.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"<Radio defaultChecked={false}  />\\n<Radio defaultChecked  />\\n\")), mdx(\"h2\", null, \"Disabled Property\"), mdx(\"p\", null, \"Use the disable property to gray out the radio button, making it un-clickable.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"<Radio disabled />\\n<Radio disabled checked />\\n\")), mdx(\"h2\", null, \"Name and ID\"), mdx(\"p\", null, \"A name and ID can be specified in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"<Radio />\"), \" component. Radio buttons of the same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" are considered to be in a 'radio group' and only one radio button in a radio group can be selected at a time.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"<Radio name=\\\"someName\\\" id=\\\"one\\\" value=\\\"one\\\"  />\\n<Radio name=\\\"someName\\\" id=\\\"two\\\" value=\\\"two\\\" />\\n<Radio name=\\\"someName\\\" id=\\\"three\\\" value=\\\"three\\\" />\\n\")), mdx(\"h2\", null, \"ReadOnly property\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Radio\"), \" will ignore user-actions when the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"readOnly\"), \" property is enabled, similar to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"disabled\"), \" but without greying out the option.\"), mdx(\"p\", null, \"NOTE: In HTML specifying \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"readonly\"), \" on \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"only\"), \" prevents changes to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" attribute of the checkbox and therefore allowing the user to still check and uncheck the checkbox.\"), mdx(\"p\", null, \"In most cases we emulate the HTML specification where it has an existing decision or feature. However, the specification's behavior around checkboxes with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"readonly\"), \" attribute is rather unintuitive.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"<Radio readOnly />\\n<Radio readOnly checked />\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"figma":"file/2MG6DoSjk4IaLnjjFCnKFf/Forms","github":"Form/Inputs/Radio/Radio.tsx","propsOf":"Radio","status":null,"title":"Radio"},"tableOfContents":{"items":[{"url":"#checked-property","title":"Checked Property"},{"url":"#disabled-property","title":"Disabled Property"},{"url":"#name-and-id","title":"Name and ID"},{"url":"#readonly-property","title":"ReadOnly property"}]}}},"pageContext":{"id":"fef86f05-dd9e-5a70-bc3b-40d458a36000"}}}